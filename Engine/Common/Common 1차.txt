Common 헤더의 역할
- 프로그램을 C나 C++로 작성하여 관리를 하려면 라이브러리에 대한 고민을 하여야 한다. 이는 크게 정적라이브러리와 동적라이브러리로 나뉜다
- DLL은 EXE와는 다른 별개의 이진 코드로서 한 번에 메모리에 로드되지 않으며 DLL이 필요한 다른 프로세스나 쓰레드에게 공유를 할 수 있는 특수성이 있다. DLL은 이진코드이기 때문에 Configuration과 PlatForm에 따라 다르기 때문에 VisualStudio 환경에서 저장시 $(Configuration)과 $(Platform)을 통해 저장을 할 수 있다
- DLL은 모듈별로 나눠지게 되어 플러그인 구조를 잡게 되고 이로 인해 컴파일 시간을 아껴준다

라이브러리를 가져오기
- 라이브러리를 코드 자체에 전처리기를 통해 경로를 지정하거나 할 수 있지만 VisualStudio와 같은 IDE를 사용하는 경우 절대경로를 지정해 편안하게 개발을 해나갈 수 있다
1. DLL을 생성한다
2. (VisualStudio라고 가정) 프로젝트 속성 - 링커 - 일반 - 추가 라이브러리 디렉터리를 통해 추가하기를 원하는 디렉터리를 설정하면 끝!

DLL만으로 불가능한 경우
- 명세와 마찬가지인 헤더파일을 포함해야 할 때가 있다. 이때도 IDE 환경이라면 편하게 include를 할 수 있다.
- 프로젝트 속성 - C/C++ - 일반 - 추가 포함 디렉터리 에서 추가하기를 원하는 디렉터리를 설정하면 끝!!

절대 경로의 한계성
- 프로그램은 혼자 개발하지 않는 이상 여러 구성원들과 함께 개발하게 된다. 이때 절대 경로로 설정하면 문제가 발생할 수 있기 때문에 매크로($(SolutionDir), $(ProjectDir))를 사용하여 상대 경로를 사용해야한다!

DLL은 다른 소스코드에서 사용이 가능한 코드로, 외부에서 접근을 하려면 그것이 가능함을 명시하는 것이 중요하다. 
(중요) dllexport, dllimport
__declspec(dllexport) 와 같은 식으로 명시를 한다. 하지만 생김새에서 알 수 있듯 언더바 두개와 시스템 명령어 같은 것을 하고 괄호 안에 dllexport와 같은 키워드를 넣어야 비로소 적용이 되는 굉장히 불쾌하게 생긴 외형을 갖고 있다. 따라서 C의 문법인 매크로와 전처리를 통해 이것을 바꿔 표현할 수 있다

#defin DLLEXPORT __declspec(dllexport) 이렇게 C의 문법을 이용하면 DLLEXPORT와 같은 식으로 비교적 간편하게 선언을 할 수 있다. 하지만 이렇게 한다고 해서 문제가 끝나는것은 아니다!

DLLEXPORT를 지정할 때도, DLLIMPORT를 지정할 때도 있기 때문에 이것을 수정해주어야하는데, 매번, 그리고 여러 곳에서 키워드를 찾아 일일히 바꾸기란 쉽지가 않다. 그래서 #if문을 사용하면 비로소 스위치처럼 이들의 상태를 바꿀 수 있게 된다. 즉, 엔진(dll)을 가져다 쓰는 쪽에서는 자동으로 import가, 엔진 내부에서 빌드할 때는 export하게 된다.




